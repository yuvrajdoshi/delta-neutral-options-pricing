import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import sys
import os

# Add paths for strategy components
sys.path.append(os.path.dirname(__file__))

from real_world_strategy import RealWorldVolatilityArbitrageStrategy, create_default_config, Signal, Position
from market_data import MarketDataManager

class BacktestResult:        print(f"\nüéØ REAL-WORLD BACKTEST: {symbol}")
        print(f"üìÖ Period: {start_date} to {end_date}")
        
        # Handle threshold override for testing
        original_threshold = self.strategy.entry_threshold
        if test_volatility_threshold is not None:
            self.strategy.entry_threshold = test_volatility_threshold
        
        print(f"   Using test threshold: {test_volatility_threshold:.1%} (vs normal {original_threshold:.1%})")t numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import sys
import os

# Add paths for strategy components
sys.path.append(os.path.dirname(__file__))

from real_world_strategy import RealWorldVolatilityArbitrageStrategy, create_default_config, Signal, Position
from market_data import MarketDataManager

class BacktestResult:
    """Container for backtest results and performance metrics"""
    
    def __init__(self):
        self.daily_returns = []
        self.daily_portfolio_values = []
        self.trades = []
        self.signals_generated = 0
        self.signals_executed = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.total_pnl = 0.0
        self.max_drawdown = 0.0
        self.dates = []
        
    def add_daily_result(self, date: datetime, portfolio_value: float, daily_return: float):
        """Add daily result to backtest"""
        self.dates.append(date)
        self.daily_portfolio_values.append(portfolio_value)
        self.daily_returns.append(daily_return)
        
    def add_trade(self, position: Position, exit_pnl: float):
        """Add completed trade to results"""
        self.trades.append({
            'entry_date': position.entry_time,
            'signal_type': position.signal.type,
            'entry_price': position.entry_price,
            'quantity': position.quantity,
            'pnl': exit_pnl,
            'vol_spread': position.signal.vol_spread,
            'strike': position.signal.strike
        })
        
        if exit_pnl > 0:
            self.winning_trades += 1
        else:
            self.losing_trades += 1
            
        self.total_pnl += exit_pnl
    
    def calculate_metrics(self) -> Dict:
        """Calculate comprehensive performance metrics"""
        if not self.daily_returns:
            return {}
        
        returns = np.array(self.daily_returns)
        portfolio_values = np.array(self.daily_portfolio_values)
        
        # Basic performance metrics
        total_return = (portfolio_values[-1] - portfolio_values[0]) / portfolio_values[0]
        annualized_return = (1 + total_return) ** (252 / len(returns)) - 1
        volatility = np.std(returns) * np.sqrt(252)
        sharpe_ratio = annualized_return / volatility if volatility > 0 else 0
        
        # Drawdown calculation
        peak = np.maximum.accumulate(portfolio_values)
        drawdown = (portfolio_values - peak) / peak
        max_drawdown = np.min(drawdown)
        
        # Win rate and profit factor
        total_trades = self.winning_trades + self.losing_trades
        win_rate = self.winning_trades / total_trades if total_trades > 0 else 0
        
        winning_pnl = sum(trade['pnl'] for trade in self.trades if trade['pnl'] > 0)
        losing_pnl = abs(sum(trade['pnl'] for trade in self.trades if trade['pnl'] < 0))
        profit_factor = winning_pnl / losing_pnl if losing_pnl > 0 else float('inf')
        
        # Calmar ratio
        calmar_ratio = annualized_return / abs(max_drawdown) if max_drawdown < 0 else float('inf')
        
        return {
            'total_return': total_return,
            'annualized_return': annualized_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'calmar_ratio': calmar_ratio,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'total_trades': total_trades,
            'winning_trades': self.winning_trades,
            'losing_trades': self.losing_trades,
            'total_pnl': self.total_pnl,
            'signals_generated': self.signals_generated,
            'signals_executed': self.signals_executed,
            'execution_rate': self.signals_executed / self.signals_generated if self.signals_generated > 0 else 0
        }

class RealWorldBacktestEngine:
    """
    Comprehensive backtesting engine for volatility arbitrage strategy
    """
    
    def __init__(self, config: Dict = None):
        """
        Initialize backtesting engine
        
        Args:
            config: Strategy configuration dictionary
        """
        self.config = config or create_default_config()
        self.strategy = RealWorldVolatilityArbitrageStrategy(self.config)
        self.initial_capital = self.config['initial_capital']
        
        # Backtesting parameters
        self.transaction_cost = 0.01  # $0.01 per contract per side
        self.slippage = 0.02  # 2% slippage
        
        print(f"üèÅ RealWorldBacktestEngine initialized")
        print(f"   Initial capital: ${self.initial_capital:,.0f}")
        print(f"   Transaction cost: ${self.transaction_cost} per contract")
        print(f"   Slippage: {self.slippage:.1%}")
    
    def run_backtest(self, start_date: str, end_date: str, 
                     test_volatility_threshold: float = None,
                     symbol: str = 'SPY') -> BacktestResult:
        """
        Run comprehensive backtest with real market data
        
        Args:
            start_date: Start date for backtest (YYYY-MM-DD)
            end_date: End date for backtest (YYYY-MM-DD)
            test_volatility_threshold: Override threshold for testing
            symbol: Trading symbol (default: 'SPY')
        """
        print(f"
üéØ REAL-WORLD BACKTEST: {symbol}")
        print(f"ÔøΩ Period: {start_date} to {end_date}")
        
        # Handle threshold override for testing
        original_threshold = self.strategy.entry_threshold
        if test_volatility_threshold is not None:
            self.strategy.entry_threshold = test_volatility_threshold
        
        print(f"   Using test threshold: {test_volatility_threshold:.1%} (vs normal {original_threshold:.1%})")
        
        # Get market data
        data_manager = MarketDataManager()
        dataset = data_manager.get_comprehensive_dataset(symbol, start_date, end_date)    def execute_signal_with_costs(self, signal: Signal) -> Optional[Position]:
        """
        Execute signal with realistic transaction costs and slippage
        
        Args:
            signal: Trading signal to execute
            
        Returns:
            Position object or None if execution failed
        """
        try:
            # Calculate base position size
            position_value = self.strategy.portfolio_value * self.strategy.max_position_size
            
            # Estimate option premium with slippage
            base_premium = abs(signal.vol_spread) * signal.strike * 0.08  # Refined estimate
            
            if signal.type == 'SELL_STRADDLE':
                # Selling straddle - receive premium minus slippage
                entry_price = base_premium * (1 - self.slippage)
                quantity = -int(position_value / (entry_price * 100))
            else:
                # Buying straddle - pay premium plus slippage
                entry_price = base_premium * (1 + self.slippage)
                quantity = int(position_value / (entry_price * 100))
            
            # Apply transaction costs
            transaction_cost = abs(quantity) * self.transaction_cost * 2  # Entry + exit
            self.strategy.portfolio_value -= transaction_cost
            
            # Create and store position
            position = Position(signal, entry_price, quantity)
            self.strategy.position_id += 1
            self.strategy.positions[self.strategy.position_id] = position
            
            return position
            
        except Exception as e:
            print(f"‚ùå Error executing signal with costs: {str(e)}")
            return None
    
    def generate_performance_report(self, results: BacktestResult) -> str:
        """
        Generate comprehensive performance report
        
        Args:
            results: Backtest results
            
        Returns:
            Formatted performance report string
        """
        metrics = results.calculate_metrics()
        
        if not metrics:
            return "No results to report"
        
        report = f"""
üèÜ VOLATILITY ARBITRAGE STRATEGY PERFORMANCE REPORT
{'='*60}

üí∞ RETURNS & RISK METRICS
   Total Return:           {metrics['total_return']:>10.2%}
   Annualized Return:      {metrics['annualized_return']:>10.2%}
   Volatility:             {metrics['volatility']:>10.2%}
   Sharpe Ratio:           {metrics['sharpe_ratio']:>10.2f}
   Maximum Drawdown:       {metrics['max_drawdown']:>10.2%}
   Calmar Ratio:           {metrics['calmar_ratio']:>10.2f}

üìä TRADING STATISTICS
   Total Trades:           {metrics['total_trades']:>10}
   Winning Trades:         {metrics['winning_trades']:>10}
   Losing Trades:          {metrics['losing_trades']:>10}
   Win Rate:               {metrics['win_rate']:>10.1%}
   Profit Factor:          {metrics['profit_factor']:>10.2f}
   Total P&L:              ${metrics['total_pnl']:>9,.0f}

üéØ SIGNAL PERFORMANCE
   Signals Generated:      {metrics['signals_generated']:>10}
   Signals Executed:       {metrics['signals_executed']:>10}
   Execution Rate:         {metrics['execution_rate']:>10.1%}

üí° PERFORMANCE ASSESSMENT
"""
        
        # Add performance assessment
        if metrics['sharpe_ratio'] > 1.5:
            report += "   ‚úÖ EXCELLENT: Sharpe ratio exceeds 1.5 target\n"
        elif metrics['sharpe_ratio'] > 1.0:
            report += "   ‚úÖ GOOD: Solid risk-adjusted returns\n"
        else:
            report += "   ‚ö†Ô∏è  NEEDS IMPROVEMENT: Low risk-adjusted returns\n"
        
        if metrics['max_drawdown'] > -0.15:
            report += "   ‚úÖ EXCELLENT: Drawdown within 15% target\n"
        else:
            report += "   ‚ö†Ô∏è  HIGH RISK: Drawdown exceeds 15% target\n"
        
        if metrics['win_rate'] > 0.55:
            report += "   ‚úÖ GOOD: Win rate exceeds 55% target\n"
        else:
            report += "   ‚ö†Ô∏è  NEEDS IMPROVEMENT: Low win rate\n"
        
        return report

def run_comprehensive_backtest():
    """Run comprehensive backtesting analysis"""
    print("üöÄ Running Comprehensive Volatility Arbitrage Backtest")
    print("=" * 60)
    
    # Create backtesting engine
    config = create_default_config()
    engine = RealWorldBacktestEngine(config)
    
    # Test periods (using available data range)
    test_periods = [
        ('2025-01-01', '2025-08-02', 'YTD 2025'),
        ('2024-08-01', '2025-08-02', 'Last 12 months'),
    ]
    
    all_results = {}
    
    for start_date, end_date, period_name in test_periods:
        print(f"\nüìÖ Testing period: {period_name}")
        print(f"   Date range: {start_date} to {end_date}")
        
        try:
            # Run backtest
            results = engine.run_backtest(start_date, end_date, test_volatility_threshold=0.02)
            
            # Generate report
            report = engine.generate_performance_report(results)
            print(report)
            
            all_results[period_name] = results.calculate_metrics()
            
        except Exception as e:
            print(f"‚ùå Error in backtest for {period_name}: {str(e)}")
    
    # Summary comparison
    if all_results:
        print(f"\nüìä PERIOD COMPARISON SUMMARY")
        print("=" * 60)
        print(f"{'Period':<15} {'Return':>10} {'Sharpe':>8} {'Drawdown':>10} {'Trades':>8}")
        print("-" * 60)
        
        for period, metrics in all_results.items():
            if metrics:
                print(f"{period:<15} {metrics['annualized_return']:>9.1%} "
                      f"{metrics['sharpe_ratio']:>7.2f} {metrics['max_drawdown']:>9.1%} "
                      f"{metrics['total_trades']:>7}")

def main():
    """Main backtesting execution"""
    run_comprehensive_backtest()

if __name__ == "__main__":
    main()
